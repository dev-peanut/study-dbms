/*JOBS 테이블에서 JOB_ID로 직원들의 JOB_TITLE, EMAIL, 성, 이름 검색*/
SELECT * FROM JOBS;
SELECT * FROM EMPLOYEES;

SELECT JOB_TITLE, EMAIL, LAST_NAME || ' ' || FIRST_NAME NAME
/*SELECT절 JOB_TITLE, EMAIL, LAST_NAME || ' ' || FIRST_NAME NAME의 값을 가져온다.*/
FROM JOBS J JOIN EMPLOYEES E
/*EMPLOYEES가 JOBS의 FK를 가지고 있기 때문에 E가 다 J가 일*/
ON J.JOB_ID = E.JOB_ID
/*J.JOB_ID는 PK E.JOB_ID는 FK가 같다.*/
WHERE First_Name = 'Lex';

/*등호가 있는 것은 등가JOIN*/
/*ON절이 WHERE절보다 선행으로 이루어 진다. JOIN이랑*/

/*EMP 테이블의 SAL을 SALGRADE 테이블의 등급으로 나누기*/
/*반드시 관계가 있어야 JOIN을 할 수 있는게 아니다.*/
/*등호가 없는 것은 비등가JOIN*/
SELECT * FROM EMP;
SELECT * FROM SALGRADE;

SELECT * /*컬럼 목록*/
FROM SALGRADE S JOIN EMP E
/*SALGRADE가 선행으로 오는 이유? INSERT쿼리가 나갈 수 없음 추가될게 없기 때문*/
/*EMP에는 추가 할 수있기때문에 후행절에 온다.*/
/*ON절 : JOIN할 조건*/
ON E.SAL BETWEEN S.LOSAL AND S.HISAL;
/*EMPLOYEES의 SAL가 SALGRADE의 LOSAL부터 HISAL까지의 값으로 조회*/
/*세타 조인, 막 조인 : 여러개*/

SELECT *
FROM SALGRADE S, EMP E
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;

/*EMPLOYEES 테이블에서 HIREDATE가 2003~2005년까지인 사원의 정보와 부서명 검색*/
SELECT * FROM EMPLOYEES;
SELECT * FROM JOBS;


/* *는 테이블이 1개 일때 쓸 수 있다. */
/* 전체정보를 보고 싶다면 어떤 테이블인지 앞에 써줘야 한다. */
SELECT D.DEPARTMENT_NAME, E.* 
FROM DEPARTMENTS D JOIN EMPLOYEES E 
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
AND E.HIRE_DATE BETWEEN TO_DATE('2003', 'YYYY') AND TO_DATE('2005', 'YYYY');
/*TO_DATE는 문자열을 DATE로 바꿔주고 DATE를 문자열로 바꿔주는 것*/


/*내 컴퓨터 FORMAT 확인*/
SELECT SYS_CONTEXT('USERENV', 'NLS_DATE_FORMAT') FROM DUAL;
/*왠만하면 FORMAT은 안바꾸는게 좋다.*/
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY';
/*내 컴퓨터 FORMAT을 'YYYY'로 바꿔준다.*/
ALTER SESSION SET NLS_DATE_FORMAT = 'RR/MM/DD';

/*JOB_TITLE 중 'Manager'라는 문자열이 포함된 직업들의 평균 연봉을 JOB_TITLE별로 검색*/
SELECT * FROM JOBS;
SELECT * FROM EMPLOYEES;
/*
 * 차이점
 * 1번째는 JOB_TITLE만 가지고 있고 즉, 한사람의 연봉
 * 2번째는 JOB_TITLE별 각각의 중복되는 사원들 정보까지 가지고 있다.
 * 그래서 각 JOB_TITLE별 평균 연봉을 알 수 있다.
 * 
 * */
SELECT JOB_TITLE FROM JOBS WHERE JOB_TITLE LIKE '%Manager%';

SELECT JOB_TITLE, AVG(SALARY)
FROM JOBS J JOIN EMPLOYEES E
ON J.JOB_ID = E.JOB_ID AND JOB_TITLE LIKE  '%Manager%'
GROUP BY JOB_TITLE;/*JOB_TITLE별이니까 묶어줘야한다.*/

SELECT JOB_TITLE, AVG(SALARY) "AVERAGE OF SALARY"
FROM JOBS J JOIN EMPLOYEES E
ON J.JOB_ID = E.JOB_ID AND JOB_TITLE LIKE '%Manager%'
GROUP BY JOB_TITLE;
/*GROUP BY는 최대한 HAVING절에서 쓰지말고 WHERE절에서 쓰자*/
/*JOIN은 WHERE절 쓰지말고 ON절에서 끊자*/

/*EMP 테이블에서 ENAME에 L이 있는 사원들의 DNAME과 LOC 검색*/
SELECT * FROM EMP;
SELECT * FROM DEPT;

SELECT ENAME, DNAME, LOC
FROM DEPT D JOIN EMP E
ON D.DEPTNO = E.DEPTNO AND ENAME LIKE '%L%';

SELECT ENAME, DNAME, LOC FROM DEPT D JOIN EMP E
ON D.DEPTNO = E.DEPTNO AND ENAME LIKE '%L%';

/*축구 선수들 중에서 각 팀별로 키가 가장 큰 선수들 전체 정보 검색*/
SELECT * FROM PLAYER;
SELECT * FROM TEAM;

SELECT TEAM_NAME, MAX(NVL(HEIGHT,0)) MAXHEIGHT
FROM TEAM T JOIN PLAYER P
ON T.TEAM_ID = P.TEAM_ID
GROUP BY TEAM_NAME;

/*키가 큰 선수들을 GROUP으로 묶어야 하는 이유?*/
/*GROUP으로 묶어줘야 가장 큰 선수가 나오니까*/
SELECT TEAM_ID, MAX(HEIGHT)
FROM PLAYER
GROUP BY TEAM_ID;

/*각 팀별로 키가 가장 큰 선수*/
/*전체 플레이어 정보와 각 팀별로 키가 가장 큰 선수를 JOIN해준다.*/

SELECT P1.*
FROM PLAYER P1 JOIN
(
	SELECT TEAM_ID, MAX(HEIGHT) HEIGHT FROM PLAYER
	GROUP BY TEAM_ID
) P2
ON P1.TEAM_ID = P2.TEAM_ID AND P1.HEIGHT = P2.HEIGHT
ORDER BY P1.TEAM_ID;
/* P1으로 해야하는 이유? SELECT절이 P1이니까 */

/*
 * JOIN의 함정 : 경우의 수 대로 뽑아온다.
 * 중복이 없는것끼리 묶어줘야한다.
 * 
 * 예) K01 173 K02 180 선수가 있다.(최대 키)
 * 	K02에 173인 선수가 있을 수 있는데 
 * 	HEIGHT만 JOIN을 해줬기 때문에
 * 	구별없이 중복되는 값도 가져올 수 있다.
 * 	즉, 키만 가져오니까 다른 팀의 최대값을 검색해버린다.
 * 
 * 	그 팀에 있는 그 키의 선수를 가져오려면
 * 	TEAM_ID를 가져와야 한다.
 */

/*IN LINE VIEW : FROM 서브쿼리*/
/*
 * 서브쿼리에 담긴 MAX(HEIGHT)의 경우 최대키만 담겼다면
 * PLAYER와 조인을 했기 때문에 전체 정보 중 키만 불러오게 됐다.
 * TEAM_ID도 같이 조인을 했기 때문에 SELECT절에 전체정보를 불러올 수 있게 된다.
 * */
SELECT P1.*
FROM PLAYER P1 JOIN
(
   SELECT TEAM_ID, MAX(HEIGHT) HEIGHT FROM PLAYER
   GROUP BY TEAM_ID
) P2
ON P1.TEAM_ID = P2.TEAM_ID AND P1.HEIGHT = P2.HEIGHT
ORDER BY P1.TEAM_ID;

/*(A, B) IN (C, D) : A = C AND B = D*/
SELECT * FROM PLAYER
WHERE (TEAM_ID, HEIGHT) IN (SELECT TEAM_ID, MAX(HEIGHT) HEIGHT 
FROM PLAYER GROUP BY TEAM_ID)
ORDER BY TEAM_ID;

/*EMP 테이블에서 사원의 이름과 매니저 이름을 검색*/
SELECT * FROM EMP;

/*SELF JOIN*/
SELECT E1.ENAME EMPLOYEE, E2.ENAME MANAGER 
FROM EMP E1 JOIN EMP E2
ON E1.MGR = E2.EMPNO;

/*
 * E1.MGR : 내 매니저 찾아주세요 니까 사원
 * E2.EMPNO : E1.MGR가 찾은 매니저니까 매니저
 * 
 * */

/*SQL 실행 순서*/
/*FROM > ON > JOIN > WHERE > GROUP BY > HAVING > SELECT > ORDER BY*/

/*[브론즈]*/
/*PLAYER 테이블에서 키가 NULL인 선수들은 키를 170으로 변경하여 평균 구하기(NULL 포함)*/
SELECT * FROM PLAYER;

SELECT AVG(NVL(HEIGHT, 170)) AS "평균 키" FROM PLAYER;

SELECT AVG(NVL(HEIGHT, '170')) AS "평균 키" FROM PLAYER;

/*[실버]*/
/*PLAYER 테이블에서 팀 별 최대 몸무게*/
SELECT * FROM PLAYER;
SELECT * FROM TEAM;

SELECT P.TEAM_ID, MAX(WEIGHT) "최대 몸무게"
FROM TEAM T JOIN PLAYER P
ON T.TEAM_ID = P.TEAM_ID
GROUP BY P.TEAM_ID
ORDER BY P.TEAM_ID;

SELECT TEAM_ID, MAX(WEIGHT) "최대 몸무게" FROM PLAYER
GROUP BY TEAM_ID;

/*[골드]*/
/*AVG 함수를 쓰지 않고 PLAYER 테이블에서 선수들의 평균 키 구하기(NULL 포함)*/
SELECT * FROM PLAYER;
/*전체 키 합을 인원수로 나누기*/
SELECT SUM(NVL(HEIGHT, 0))/COUNT(NVL(HEIGHT,0)) "평균 키" FROM PLAYER; 

SELECT SUM(NVL(HEIGHT, 0)) / COUNT(NVL(HEIGHT, 0)) FROM PLAYER;

/*[플래티넘]*/
/*DEPT 테이블의 LOC별 평균 급여를 반올림한 값과 각 LOC별 SAL 총 합을 조회, 반올림 : ROUND()*/
SELECT * FROM DEPT;
SELECT * FROM EMP;

SELECT LOC "지역", ROUND(AVG(SAL)) "평균 급여", SUM(SAL) "급여 총 합"
FROM DEPT D JOIN EMP E
ON D.DEPTNO = E.DEPTNO
GROUP BY LOC;

SELECT LOC, ROUND(AVG(SAL), 2) "평균 급여", SUM(SAL) "총 합"
FROM DEPT D JOIN EMP E
ON D.DEPTNO = E.DEPTNO
GROUP BY LOC;

/*[다이아]*/
/*PLAYER 테이블에서 팀별 최대 몸무게인 선수 검색*/
SELECT * FROM PLAYER;
SELECT * FROM TEAM;

SELECT TEAM_ID, MAX(WEIGHT) FROM PLAYER GROUP BY TEAM_ID;


SELECT P1.TEAM_ID, P1.*
FROM PLAYER P1 JOIN 
(
	SELECT TEAM_ID, MAX(WEIGHT) WEIGHT FROM PLAYER GROUP BY TEAM_ID
) P2
ON P1.TEAM_ID = P2.TEAM_ID AND P1.WEIGHT = P2.WEIGHT
ORDER BY  P1.TEAM_ID;

SELECT *
FROM PLAYER
WHERE (TEAM_ID, WEIGHT) IN (SELECT TEAM_ID, MAX(WEIGHT) WEIGHT FROM PLAYER GROUP BY TEAM_ID)
ORDER BY TEAM_ID;

SELECT P2.* FROM 
(
   SELECT TEAM_ID, MAX(WEIGHT) MAX_WEIGHT FROM PLAYER
   GROUP BY TEAM_ID
) P1
JOIN PLAYER P2
ON P1.TEAM_ID = P2.TEAM_ID AND P1.MAX_WEIGHT = P2.WEIGHT
ORDER BY P2.TEAM_ID;

/*[마스터]*/
/*EMP 테이블에서 HIREDATE가 FORD의 입사년도와 같은 사원 전체 정보 조회*/
/*오라클 데이터 추출하기*/
SELECT TO_CHAR(HIREDATE) FROM EMP;


SELECT ENAME, TO_CHAR(HIREDATE, 'YYYY') FROM EMP WHERE ENAME = 'FORD';

SELECT * FROM EMP
WHERE TO_CHAR(HIREDATE, 'YYYY') = (SELECT TO_CHAR(HIREDATE, 'YYYY') FROM EMP WHERE ENAME = 'FORD');

SELECT * FROM EMP
WHERE TO_CHAR(HIREDATE, 'YYYY') = (SELECT TO_CHAR(HIREDATE, 'YYYY') FROM EMP WHERE ENAME = 'FORD');

/*내부 외부를 나누는 기준 조건식*/
/*내부조인 : 조건식 안에 포함되어 있는 애들만 나와라*/
/*외부 조인 : 조건식이 맞지 않아도 나와라*/
/*JOIN 할 때 선행 또는 후행 중 하나의 테이블 정보를 모두 확인하고 싶을 때 사용한다.*/

/*서로가 서로의 FK를 가지고 있는 경우 1:1관계 - 원래를 1개의 테이블만 가지고 있었음 행의 갯수가 더 많은게 후행*/
SELECT NVL(TEAM_NAME, '공용'), S.*
FROM TEAM T RIGHT OUTER JOIN STADIUM S
ON T.TEAM_ID = S.HOMETEAM_ID;

/*DEPARTMENTS 테이블에서 매니저 이름 검색, 매니저가 없더라도 부서명 모두 검색*/
SELECT * FROM DEPARTMENTS;
SELECT * FROM EMPLOYEES;

SELECT D.DEPARTMENT_NAME, FIRST_NAME || ' ' || LAST_NAME "MANAGER"
FROM DEPARTMENTS D LEFT OUTER JOIN EMPLOYEES E
ON D.MANAGER_ID = E.EMPLOYEE_ID;

SELECT D.DEPARTMENT_NAME, NVL(E.LAST_NAME, 'NO') || ' ' || NVL(E.FIRST_NAME, 'NAME')
FROM DEPARTMENTS D LEFT OUTER JOIN EMPLOYEES E
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID AND D.MANAGER_ID = E.EMPLOYEE_ID;

SELECT * FROM EMPLOYEES;

/*EMPLOYEES 테이블에서 사원의 매니저 이름, 사원의 이름 조회, 매니저가 없는 사원은 본인이 매니저임을 표시*/
SELECT * FROM EMPLOYEES;
SELECT * FROM DEPARTMENTS;

SELECT FIRST_NAME || ' ' || LAST_NAME "MANAGER" 
FROM DEPARTMENTS D LEFT OUTER JOIN EMPLOYEES E
ON D.MANAGER_ID = E.EMPLOYEE_ID;

SELECT *
FROM EMPLOYEES E1 JOIN EMPLOYEES E2
ON E1.MANAGER_ID = E2.EMPLOYEE_ID;


SELECT E1.FIRST_NAME "사원 이름", NVL(E2.FIRST_NAME, E1.FIRST_NAME) "매니저 이름"
FROM EMPLOYEES E1 LEFT OUTER JOIN EMPLOYEES E2
ON E1.MANAGER_ID = E2.EMPLOYEE_ID;

/*EMPLOYEES에서 각 사원별로 관리부서(매니저)와 소속부서(사원) 조회*/
SELECT E1.JOB_ID 관리부서, E2.JOB_ID 소속부서, E2.FIRST_NAME 이름
FROM
(
   SELECT JOB_ID, MANAGER_ID FROM EMPLOYEES
   GROUP BY JOB_ID, MANAGER_ID
) E1 
FULL OUTER JOIN EMPLOYEES E2
ON E1.MANAGER_ID = E2.EMPLOYEE_ID
ORDER BY 소속부서 DESC;

/*VIEW*/
/*CREAT VIEW [이름] AS [쿼리문]*/
/*
 * 기존의 테이블을 그대로 놔둔 채 필요한 컬럼들 및 새로운 컬럼을 만든 가상 테이블.
 * 실제 데이터가 저장되는 것은 아니지만 VIEW를 통해서 데이터를 관리할 수 있다.
 * 
 * - 독립성 : 다른 곳에서 접근하지 못하도록 하는 성질
 * - 편리성 : 길고 복잡한 쿼리문을 매번 작성할 필요가 없다.
 * - 보안성 : 기존의 쿼리문이 보이지 않는다.
 * 
 */

/*PLAYER 테이블에 나이 컬럼 추가한 뷰 만들기*/
CREATE VIEW VIEW_PLAYER AS
SELECT FLOOR((SYSDATE - BIRTH_DATE) / 365) AGE, P.* FROM PLAYER P;

SELECT * FROM VIEW_PLAYER WHERE AGE < 40;

/*EMPLOYEES 테이블에서 사원 이름과 그 사원의 매니저 이름이 있는 VIEW 만들기*/
SELECT * FROM EMPLOYEES;

CREATE VIEW VIEW_EMPLOYEES AS
SELECT E1.FIRST_NAME "사원 이름", E2.FIRST_NAME "매니저 이름"
FROM EMPLOYEES E1 JOIN EMPLOYEES E2
ON E1.MANAGER_ID = E2.EMPLOYEE_ID;

SELECT * FROM VIEW_EMPLOYEES;

/*PLAYER 테이블에서 TEAM_NAME 컬럼을 추가한 VIEW 만들기*/
SELECT * FROM PLAYER;

CREATE VIEW VIEW_PLAYER_NAME AS
SELECT T.TEAM_NAME, P.*  
FROM TEAM T JOIN PLAYER P 
ON P.TEAM_ID = T.TEAM_ID;

SELECT * FROM VIEW_PLAYER_NAME;










